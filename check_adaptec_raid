#!/usr/bin/perl -w


use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
use Data::Dumper;
use Switch;

our $VERBOSITY = 0;
our $VERSION = '0.1.3.4.6.233-ALPHA';
our $NAME = "Thomas-Krenn AG Adaptec Raid Controller Nagios/Icinga Plugin";
our $EXITSTATUS = 0;
use constant { 
	STATE_OK => 0,
	STATE_WARNING => 1,
	STATE_CRITICAL => 2,
	STATE_UNKNOWN => 3,
 };

# Returns StatusCode 0,1,2,3
sub myStatus {
	my $prevStatus = $_[0];
	my $nextStatus = $_[1];
	my $returnStatus = STATE_OK;
	if ($prevStatus >= $nextStatus) {
		$returnStatus = $prevStatus;
	} else {
		$returnStatus = $nextStatus;
	}
	
	return $returnStatus;
}

# Explains the Usage of the plugin, also which options take which values
# TODO: finished?!
#Usage:
#check_ipmi_sensor -H <hostname>
  #[-f <FreeIPMI config file> | -U <username> -P <password> -L <privilege level>]
  #[-O <FreeIPMI options>] [-b] [-T <sensor type>] [-x <sensor id>] [-v|-vv|-vvv]
  #[-o zenoss] [-h] [-V]
sub displayUsage {
	print $NAME . "V.: " . $VERSION ."\n";
	print "Usage:\n";
	print "  [ -C <Controller number> ] [ -LD <Logical device number> ]\n";
	print "  [ -PD <Physical device number> ] [ -T <Temperature> ]\n";
	print "  [ -p <Path>] [ -z <0/1> ]\n";
	print "  -v(-vv,-vvv) --verbose		Sets the verbosity level\n";
	print "  -h --help			Displays the Help page\n";
	print "  -V --version			Displays the Version of the plugin and arcconf\n";
	print "  -C # --controller #		Specifies a Controller number, defaults to 1\n";
	print "  -LD # --logicaldevice #		Specifies one or more Logical Devices, defaults to all\n";
	print "  -PD # --physicaldevice #	Specifies one or more Physical Devies, defaults to all\n";
	print "  -T # --temperature #		Specifies a maximum temperature the RAID-Controller may have, default is 40 C\n";
	print "  -p <str> --path <str>		Specifies the path to arcconf, default is /usr/bin/arcconf or C:\\Programme\\Adaptec\\RemoteArcconf\\arcconf.exe\n";
	print "  -z <bool> --ZMM <bool>		Boolean Value which specifies if an Zero-Maintenance Module is Present (1 is present/0 is not Present). Default is 1\n";
}

# Displays a short Help text for the user
# TODO: nicer formatting + more help?
sub displayHelp {
	print $NAME . "V.: " . $VERSION ."\n";
	print "Copyright (C) 2009-2013 Thomas-Krenn.AG";
	print "Current updates available at http://www.thomas-krenn.com/en/oss/<NOT HERE YET!!!!!!>/\n";
	print "This Nagios/Icinga Plugin checks ADAPTEC RAID-Controllers for Controller, Physical-Device and Logical Device warnings and errors. \n";
	print "Requires arcconf, Nagios/Icinga, sudo\n";
	print "In order for this plugin to work properly you need to add the nagios-user(\"nagios\" in most cases) to your sudoers file (or create a new one in /etc/sudoers.d/)\n";
	print "It is highly recommended that the nagios user only gets access to arcconf! \nFor example: <nagios user> all nopasswd: /path/to/arcconf *\n";
	displayUsage();
	print "Further information about this plugin can be found at
http://www.thomas-krenn.com/en/oss/<NOT THERE YET!>
Send email to the <NOT THERE YET!>-plugin-user mailing list if you have questions regarding
use of this software, to submit patches, or suggest improvements.
The mailing list is available at http://lists.thomas-krenn.com/";
	exit(STATE_UNKNOWN);
}
 
# Prints the Name, Version of the Plugin
# Also Prints the name, version of arcconf and the version of the RAID-Controller
sub displayVersion {
	my $sudo = $_[0];
	my $arcconf = $_[1];
	my @arcconfVersion = `$sudo $arcconf`;
	print $NAME . "\nVersion: ". $VERSION . "\n\n";
	foreach my $line (@arcconfVersion){
		if(index($line, "| UCLI |" ) ne "-1") {
			$line =~ s/\s+\|.UCLI.\|\s+//g;
			print $line. "";
		}
	}
}

# Returns Information about the Adaptec RAID-Controller itsself:
#		- Controller Status
#		- Defunctional Disks
#		- Logical Devices which have failed/are degraded
#		- Temperature
# 		- Status of ZMM if present
# TODO: Nagios Dev Guidelines correct Threshold implementation (currently just takes > for warning and +20% for critical)

sub getControllerCfg {
	
	my $sudo = $_[0];
	my $arcconf = $_[1];
	my $controller = $_[2];
	my $temperature = $_[3];
	my $zmm = $_[4];
	my $status = 0; # Return Status
	my $statusMessage = ''; # Return String
	my @output = `$sudo $arcconf GETCONFIG $controller AD`; #seems to parse every line in its own variable
	my @linevalues;
	
	foreach my $line (@output) {
		if(index($line, ':') != -1) {
			@linevalues = split(/:/, $line);
			$linevalues[0] =~ s/^\s+|\s+$//g;
			$linevalues[1] =~ s/^\s+|\s+$//g;

			switch($linevalues[0]) {
				# Overall Controller Status
				case "Controller Status" {
					if ($linevalues[1] ne "Optimal") {
						$status = myStatus($status, STATE_CRITICAL);
						if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. Status critical, "; }
						if ($VERBOSITY == 1) {$statusMessage .= "Controller Status is critical, "; }
						if ($VERBOSITY >= 2) {$statusMessage .= "The Controller Status is not running Optimal, "; }
					}
				}
				# Defunctional disks
				case "Defunct disk drive count" { 
					if ($linevalues[1] ne "0") { 
						$status = myStatus($status, STATE_CRITICAL);
						if ($VERBOSITY == 0) {$statusMessage .= "Defunct. disks, "; }
						if ($VERBOSITY >= 1) {$statusMessage .= $linevalues[1] . " disks are defunctional, "; }
					}
				}
				
				# Logical Devices total/failed/degraded
				# Warning since the raid is still recoverable, if it isnt you wont need a nagios plugin to notice that!
				case "Logical devices/Failed/Degraded" { 
					$linevalues[1] =~ /([0-9]+)\/([0-9]+)\/([0-9]+)/;
					my $totalDisks = $1;
					my $totalFailed = $2;
					my $totalDegraded = $3;
					if ($totalFailed ne '0' || $totalDegraded ne '0') { 
						$status = myStatus($status, STATE_WARNING);
						if ($VERBOSITY == 0) {$statusMessage .= "Log. device failed/degraded, "; }
						if ($VERBOSITY == 1) {$statusMessage .= "Logical devices have failed or are degraded, "; }
						if ($VERBOSITY == 2) {$statusMessage .= "Disks have failed or the Raid is degraded, "; }	
						if ($VERBOSITY == 3) {$statusMessage .= "Disks have failed or the Raid is degraded: (Total Disks: ". $totalDisks . ", Failed: " . $totalFailed . ", Degraded: " . $totalDegraded . "), "; }
					}
				}
				
				# Warning if temperature is over the set Threshold 
				# Critical if 20% over the set Threshold (Will be configureable in the future)
				# http://nagiosplug.sourceforge.net/developer-guidelines.html#THRESHOLDFORMAT
				# Simple: 
				# 		-w % for warning
				#		-c % for critical
				case "Temperature" {
					my ($controllerTemp) = $linevalues[1] =~ /(^[0-9]+)/;
					my $criticalTemp = $temperature + (2 * ( $temperature / 10 ));
					if ( $controllerTemp > $criticalTemp) {
						$status = myStatus($status, STATE_CRITICAL);
						if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. critical, "; }
						if ($VERBOSITY == 1) {$statusMessage .= "Temperature critical: " . $controllerTemp . " C, "; }
						if ($VERBOSITY == 2) {$statusMessage .= "Temperature critical: (20% over threshold): " . $controllerTemp . " C, "; }	
						if ($VERBOSITY == 3) {$statusMessage .= "Temperature critical: (20% over threshold: ". $criticalTemp . " C):" . $controllerTemp . " C, "; }
					} elsif ($controllerTemp > $temperature) {
						$status = myStatus($status, STATE_WARNING);
						if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. warning, "; }
						if ($VERBOSITY == 1) {$statusMessage .= "Temperature Warning:" . $controllerTemp . " C, "; }
						if ($VERBOSITY == 2) {$statusMessage .= "Temperature Warning (Threshold: ". $temperature. " C): " . $controllerTemp . " C,"; }
						if ($VERBOSITY == 3) {$statusMessage .= "Temperature Warning (Threshold: ". $temperature. ", Critical Threshold:". $criticalTemp ." C):" . $controllerTemp . " C, "; }
					}		
				}
				
				# Zero Maintenance Module
				case "Status" { 
					if ( $zmm == 1) {
						if ($linevalues[1] ne "ZMM Optimal") { 
							$status = myStatus($status, STATE_CRITICAL);
							if ($VERBOSITY == 0) {$statusMessage .= "ZMM critical, "; }
							if ($VERBOSITY == 1) {$statusMessage .= "ZMM Module state critical, "; }
							if ($VERBOSITY >= 2) {$statusMessage .= "Zero Maintenance Module Error or Module not found!, "; }	
						}
					}
				}
			}
		}
		
	}
	return ($status, $statusMessage);
}

# TODO: Comment what this thing does
sub getPhysDevCfg {
	my $sudo = $_[0];
	my $arcconf = $_[1];
    my $controller = $_[2];
    my @devices = $_[3];
    my $devicenum = -1;
    my $status = 0; #Return Status
    my $statusMessage = ''; # Return String
    my @faildevices;
    my @output = `$sudo $arcconf GETCONFIG $controller PD`;
    my @linevalues;
    
    foreach my $line (@output) {
        if($line =~ /(Device #)([0-9]+)/) {
        	if(!defined($devices[0])) {
        		$devicenum = $2;
        	} else {
        		if(grep {$_ eq $2} @devices) {
        			$devicenum = $2;
        		} else {
        			$devicenum = -1;
        		}
        	}
        }
        if($devicenum ne -1 && index($line, ':') != -1) {
            @linevalues = split(/:/, $line);
            $linevalues[0] =~ s/^\s+|\s+$//g;
            $linevalues[1] =~ s/^\s+|\s+$//g;

            switch($linevalues[0]) {
            
            	# Main disk status (Online/Offline?)
                case "State" {
                    if ($linevalues[1] ne "Online") {
						#check if device is in failed array, else add it
                    	if(!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY == 0) {$statusMessage .= "Disk offline, "; }
                        if ($VERBOSITY >= 1) {$statusMessage .= "Disk $devicenum is offline, "; }
                    }
                }
            	
            	# Overall S.M.A.R.T. status
                case "S.M.A.R.T." {
                    if ($linevalues[1] ne "No") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                    	$status = myStatus($status, STATE_CRITICAL);
                    	if ($VERBOSITY == 0) {$statusMessage .= "S.M.A.R.T. critical, "; }
                        if ($VERBOSITY >= 1) {$statusMessage .= "Disk $devicenum: S.M.A.R.T. status critical, "; }
                    }
                }
            	
            	# Check if any S.M.A.R.T. warnings occured
                case "S.M.A.R.T. warnings" {
                    if ($linevalues[1] ne "0") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_WARNING);
                        if ($VERBOSITY == 0) {$statusMessage .= "S.M.A.R.T. warning, "; }
                        if ($VERBOSITY == 1) {$statusMessage .= "Disk $devicenum: S.M.A.R.T. warnings, "; }
                        if ($VERBOSITY >= 2) {$statusMessage .= "Disk $devicenum: \nDisk has one or more S.M.A.R.T. warnings, "; }
                    }
                }
            	
            	# Check if the disk does not run with full (physical) speed
                case "Power state" {
                	if ($linevalues[1] ne "Full rpm") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY == 0) {$statusMessage .= "Low rpm Warning, "; }
                        if ($VERBOSITY == 1) {$statusMessage .= "Disk $devicenum does not run with full speed, "; }
                        if ($VERBOSITY >= 2) {$statusMessage .= "Disk $devicenum: \nDisk run in a different power state (not full rpm), "; }
                	}
                }
            	
            	# Look for bad device segments
                case "Failed logical device segments" {
                	if ($linevalues[1] eq "True") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY == 0) {$statusMessage .= "Log. device Failed segm, "; }
                        if ($VERBOSITY >= 1) {$statusMessage .= "Disk $devicenum has failed logical device segments, "; }
                	}
                }
            }
        }
    }
	#FIXME What if devicenum is -1 here? Print a warning that PD num has not been found
    
    # Status output
    # TODO: print number of failed disks in verbosity level 0?

=begin
    my $faildevicenum = scalar(@faildevices);
    if ($VERBOSITY eq 0 && $faildevicenum > 0) {
    	if ($status eq 1) {
    		$statusMessage = "WARNING: Problems with $faildevicenum physical disk(s).";
    	} else {
    		$statusMessage = "CRITICAL: Problems with $faildevicenum physical disk(s)."
    	}
    }
=cut
    return ($status, $statusMessage);
}


sub getLogDevCfg {
	my $sudo = $_[0];
	my $arcconf = $_[1];
    my $controller = $_[2];
    my @devices = $_[3];
    my $devicenum = -1;
    my $status = 0; #Return status
    my $statusMessage = ''; #Return string
    my @faildevices;
    my @output = `$sudo $arcconf GETCONFIG $controller LD`;
    my @linevalues;
   
    foreach my $line (@output) {
        if($line =~ /(Logical device number )([0-9]+)/) {
        	if(!defined($devices[0])) {
        		$devicenum = $2;
        	} else {
        		if(grep {$_ eq $2} @devices) {
        			$devicenum = $2;
        		} else {
        			$devicenum = -1;
        		}
        	}
        }
        if($devicenum ne -1 && index($line, ':') != -1) {
            @linevalues = split(/:/, $line);
            $linevalues[0] =~ s/^\s+|\s+$//g;
            $linevalues[1] =~ s/^\s+|\s+$//g;

            switch($linevalues[0]) {
            
            	# Main logical device status (Optimal/Failed?)
                case "Status of logical device" {
                    if ($linevalues[1] ne "Optimal") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY == 0) {$statusMessage .= "Log. device critical, "; }
                        if ($VERBOSITY >= 1) {$statusMessage .= "State of logical disk $devicenum is not optimal, "; }
                    }
                }
            	
            	# Check for failed stripes
                case "Failed stripes" {
                    if ($linevalues[1] ne "No") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                    	$status = myStatus($status, STATE_CRITICAL);
                    	if ($VERBOSITY == 0) {$statusMessage .= "Failed stripes, "; }
                        if ($VERBOSITY >= 1) {$statusMessage .= "Logical disk $devicenum has failed stripes, "; }
                    }
                }
            }
        }
    }
    
	#FIXME What if devicenum is -1 here? Print a warning that PD num has not been found

    # Status output
	#TODO Print number of PD failed e.g. Critical [PD failed=2]
=begin
    my $faildevicenum = scalar(@faildevices);
    if ($VERBOSITY eq 0 && $faildevicenum > 0) {
    	if ($status eq 1) {
    		$statusMessage = "WARNING: Problems with $faildevicenum logical disk(s).";
    	} else {
    		$statusMessage = "CRITICAL: Problems with $faildevicenum logical disk(s)."
    	}
    }
=cut
    return ($status, $statusMessage);
}


MAIN: {
	my $controller = 1;
	my @logDevices; 
	my @physDevices;
	my $sudo = ''; 
	my $arcconf = '';
	my $platform = $^O;
 	my $temperature = 40;
 	my $zmm = 1; # boolean
 	my $statusMessage = ''; # printed status message
	
	if ( !(GetOptions(
		'v|verbose' => sub {$VERBOSITY = 1 },
		'vv' => sub {$VERBOSITY = 2},
		'vvv' => sub {$VERBOSITY = 3},
		'h|help' => sub {displayHelp();},
		'V|version' => sub {displayVersion($sudo, $arcconf);},
		'C|controller=i' => \$controller,
		'LD|logicaldevice=i{,}' => \@logDevices,
		'PD|physicaldevice=i{,}' => \@physDevices, 
		'T|temperature=i' => \$temperature, #mit -w -c ersetzen?!
		'p|path=s' => \$arcconf,
		'z|ZMM=i' => \$zmm
	)))	{
		displayUsage();
		exit(STATE_UNKNOWN);
	}

	# Check platform
	if ($platform eq 'linux') {
		chomp($sudo= `which sudo`);
		if ($arcconf eq '') {
			$arcconf = '/usr/bin/arcconf';
		}
		unless ( -e $arcconf && -x $sudo ) {
			print "Permission denied or file not found!\n";
			exit(STATE_UNKNOWN);
		}
	} else {
		$sudo = '';
		if ($arcconf eq '') {
			$arcconf = 'C:\Programme\Adaptec\RemoteArcconf\arcconf.exe';
		}
		unless ( -e $arcconf ) { print "Executable not found!\n"; exit(3); }
	}
	
 	# Input validation
 	my @controllerVersion = `$sudo $arcconf GETVERSION $controller`;
 	if($controllerVersion[1] eq "Invalid controller number.") {
 		print "Invalid controller number, device not found!";
 		exit(STATE_UNKNOWN);
 	}
	if(!$zmm =~ /(^[0-1]+)/) {
 		print "Invalid ZMM parameter, must be 0 or 1!";
		exit(STATE_UNKNOWN);
	}	

	# Set exit status
	my $newexitstatus = 0;
	my $newstatusMessage = '';
	($newexitstatus, $statusMessage) = getControllerCfg($sudo, $arcconf, $controller, $temperature, $zmm);
	$newstatusMessage .= $statusMessage;
	$EXITSTATUS = myStatus($newexitstatus, $EXITSTATUS);
	($newexitstatus, $statusMessage) = getPhysDevCfg($sudo, $arcconf, $controller, @physDevices);
	$newstatusMessage .= $statusMessage;
	$EXITSTATUS = myStatus($newexitstatus, $EXITSTATUS);
	($newexitstatus, $statusMessage) = getLogDevCfg($sudo, $arcconf, $controller, @logDevices);
	$newstatusMessage .= $statusMessage;
	$EXITSTATUS = myStatus($newexitstatus, $EXITSTATUS);
	switch($EXITSTATUS) {
		case 0 { print "AACRAID OK (Ctrl #$controller)\n"; }
		case 1 { if($VERBOSITY eq 0) { chop($newstatusMessage); chop($newstatusMessage); } print "AACRAID WARNING (Ctrl #$controller): [$newstatusMessage]\n"; }
		case 2 { if($VERBOSITY eq 0) { chop($newstatusMessage); chop($newstatusMessage); } print "AACRAID CRITICAL (Ctrl #$controller): [$newstatusMessage]\n"; }
	}
	exit($EXITSTATUS);
}

__END__

=head1 NAME

check_adaptec_raid - nagios/icinga plugin to check adaptec raid controllers

=head1 VERSION

This document describes plugin version 0.0.1

=head1 DESCRIPTION

=head1 METHODS

=head2 myStatus

TODO: Description

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2013,
Martin Grubhofer C<< <mgrubhofer@thomas-krenn.com> >>.
Franz Nemeth C<< <fnemeth@thomas-krenn.com> >>.
All rights reserved.

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See L<perlartistic>.

=head1 DISCLAIMER OF WARRANTY

BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.
