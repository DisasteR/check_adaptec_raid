#!/usr/bin/perl -w


use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
use Data::Dumper;
use feature qw(switch);

our $VERBOSITY = 0;
our $VERSION = '0.1';
our $NAME = "Thomas-Krenn AG Adaptec Raid Controller Nagios/Icinga Plugin";
our $EXITSTATUS = 0;
use constant { 
	STATE_OK => 0,
	STATE_WARNING => 1,
	STATE_CRITICAL => 2,
	STATE_UNKNOWN => 3,
 };

# Returns StatusCode 0,1,2,3
sub myStatus {
	my $prevStatus = $_[0];
	my $nextStatus = $_[1];
	my $returnStatus = STATE_OK;
	if ($prevStatus >= $nextStatus) {
		$returnStatus = $prevStatus;
	} else {
		$returnStatus = $nextStatus;
	}
	
	return $returnStatus;
}


# Explains the Usage of the plugin, also which options take which values
sub displayUsage {
	print "Usage: \n";
	print "  [ -C <Controller number> ] [ -LD <Logical device number> ]\n";
	print "  [ -PD <Physical device number> ] [ -T <Warning Temp., Crit. Temp.> ]\n";
	print "  [ -p <Path> ] [ -z <0/1> ]\n";
	print "  [ -h | --help ]\n	Display this help page\n";
	print "  [ -v | -vv | -vvv | --verbose ]\n	Sets the verbosity level\n	no -v single line output for Nagios/Icinga\n	-v   single line with more details\n	-vv  multiline output for debugging errors and more detailed information\n	-vvv is for plugin problem diagnosis\n";
	print "  [ -V --version ]\n	Displays the Version of the tk-adaptec-plugin and the version of arcconf\n";
	print "  [ -C <Controller Number> | --controller <Controller Number> ]\n	Specifies a Controller number, (Default 1).\n";
	print "  [ -LD | --logicaldevice <Log. device number> ]\n	Specifies one or more Logical Devices to monitor.\n	Accepts a positive Integer or a comma seperated list as additional argument\n	(Default all)\n";
	print "  [ -PD | --physicaldevice <Phys. device number> ]\n	Specifies one or more Physical Devies to monitor.\n	Accepts a positive Integer or a comma seperated list as additional argument\n	(Default all)\n";
	print "  [ -T | --temperature <W,C>]\n	Specifies a Warning,Critical temperature(e.g. -T 30,40) for the RAID-Controller.\n	(Default Warning 50 C, Critical 60 C)\n";
	print "  [ -p <path> | --path <path>]\n	Specifies the path to arcconf.\n	Default is /usr/bin/arcconf  C:\\Programme\\Adaptec\\RemoteArcconf\\arcconf.exe\n";
	print "  [ -z <0/1> | ZMM <0/1> ]\n	Boolean Value which specifies if a Zero-Maintenance Module is available\n	(1 is available, 0 is not available). (Default 1)\n	This option is required if you have an Adaptec Raid Controller without a ZMM.\n\n";
}

# Displays a short Help text for the user
# TODO: ADD URL and Mailing List
sub displayHelp {
	print $NAME . " Version: " . $VERSION ."\n";
	print "Copyright (C) 2009-2013 Thomas-Krenn.AG\n";
	print "Current updates available at http://www.thomas-krenn.com/en/oss/<NOT HERE YET!!!!!!>/\n";
	print "This Nagios/Icinga Plugin checks ADAPTEC RAID-Controllers for Controller, \nPhysical-Device and Logical Device warnings and errors. \n";
	print "In order for this plugin to work properly you need to add the \nnagios-user to your sudoers file (or create a new one in /etc/sudoers.d/)\n";
	displayUsage();
	print "Further information about this plugin can be found at
http://www.thomas-krenn.com/en/oss/<NOT THERE YET!>
Send email to the <NOT THERE YET!>-plugin-user mailing list if you have questions regarding
use of this software, to submit patches, or suggest improvements.
The mailing list is available at http://lists.thomas-krenn.com/";
	exit(STATE_UNKNOWN);
}
 
# Prints the Name, Version of the Plugin
# Also Prints the name, version of arcconf and the version of the RAID-Controller
sub displayVersion {
	my $sudo = $_[0];
	my $arcconf = $_[1];
	my @arcconfVersion = `$sudo $arcconf`;
	print $NAME . "\nVersion: ". $VERSION . "\n\n";
	foreach my $line (@arcconfVersion){
		if(index($line, "| UCLI |" ) ne "-1") {
			$line =~ s/\s+\|.UCLI.\|\s+//g;
			print $line. "";
		}
	}
}

# Returns Information about the Adaptec RAID-Controller itsself:
#		- Controller Status
#		- Defunctional Disks
#		- Logical Devices which have failed/are degraded
#		- Temperature
# 		- Status of ZMM if present
sub getControllerCfg {
	my $sudo = $_[0];
	my $arcconf = $_[1];
	my $controller = $_[2];
	my @temperature = @{($_[3])};
	my $zmm = $_[4];
	my $status = 0; # Return Status
	my $statusMessage = ''; # Return String
	my @output = `$sudo $arcconf GETCONFIG $controller AD`;
	my @linevalues;
	
	foreach my $line (@output) {
		if(index($line, ':') != -1) {
			@linevalues = split(/:/, $line);
			$linevalues[0] =~ s/^\s+|\s+$//g;
			$linevalues[1] =~ s/^\s+|\s+$//g;

			given($linevalues[0]) {
				# Overall Controller Status
				when("Controller Status") {
					if ($linevalues[1] ne "Optimal") {
						$status = myStatus($status, STATE_CRITICAL);
						if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. Status critical, "; }
						if ($VERBOSITY == 1) {$statusMessage .= "Controller Status is critical, "; }
						if ($VERBOSITY >= 2) {$statusMessage .= "The Controller Status is not running Optimal, "; }
					}
				}
				# Defunctional disks
				when("Defunct disk drive count") { 
					if ($linevalues[1] ne "0") { 
						$status = myStatus($status, STATE_CRITICAL);
						if ($VERBOSITY == 0) {$statusMessage .= "Defunct. disks, "; }
						if ($VERBOSITY >= 1) {$statusMessage .= $linevalues[1] . " disks are defunctional, "; }
					}
				}
				
				# Logical Devices total/failed/degraded
				# Warning since the raid is still recoverable, if it isnt you wont need a nagios plugin to notice that!
				when("Logical devices/Failed/Degraded") { 
					$linevalues[1] =~ /([0-9]+)\/([0-9]+)\/([0-9]+)/;
					my $totalDisks = $1;
					my $totalFailed = $2;
					my $totalDegraded = $3;
					if ($totalFailed ne '0' || $totalDegraded ne '0') { 
						$status = myStatus($status, STATE_WARNING);
						if ($VERBOSITY == 0) {$statusMessage .= "Log. device failed/degraded, "; }
						if ($VERBOSITY == 1) {$statusMessage .= "Logical devices have failed or are degraded, "; }
						if ($VERBOSITY == 2) {$statusMessage .= "Disks have failed or the Raid is degraded, "; }	
						if ($VERBOSITY == 3) {$statusMessage .= "Disks have failed or the Raid is degraded: (Total Disks: ". $totalDisks . ", Failed: " . $totalFailed . ", Degraded: " . $totalDegraded . "), "; }
					}
				}
				
				# Warning if temperature is over the set Threshold 
				when("Temperature") {
					my ($controllerTemp) = $linevalues[1] =~ /(^[0-9]+)/;
					my $warningTemp = $temperature[0];
					my $criticalTemp = $temperature[1];
					if ( $controllerTemp > $criticalTemp ) {
						$status = myStatus($status, STATE_CRITICAL);
						if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. critical, "; }
						if ($VERBOSITY == 1) {$statusMessage .= "Temperature critical: " . $controllerTemp . " C, "; }
						if ($VERBOSITY == 2) {$statusMessage .= "Temperature critical: ". $controllerTemp . " C, "; }	
						if ($VERBOSITY == 3) {$statusMessage .= "Temperature critical (Threshold: ". $criticalTemp . " C):" . $controllerTemp . " C, "; }
					} elsif ($controllerTemp > $warningTemp) {
						$status = myStatus($status, STATE_WARNING);
						if ($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. warning, "; }
						if ($VERBOSITY == 1) {$statusMessage .= "Temperature Warning: " . $controllerTemp . " C, "; }
						if ($VERBOSITY == 2) {$statusMessage .= "Temperature Warning (Threshold: ". $warningTemp. " C): " . $controllerTemp . " C,"; }
						if ($VERBOSITY == 3) {$statusMessage .= "Temperature Warning (Threshold: ". $warningTemp. ", Critical Threshold: ". $criticalTemp ." C):" . $controllerTemp . " C, "; }
					}		
				}
				
				# Zero Maintenance Module
				when("Status") { 
					if ( $zmm == 1) {
						if ($linevalues[1] ne "ZMM Optimal") { 
							$status = myStatus($status, STATE_CRITICAL);
							if ($VERBOSITY == 0) {$statusMessage .= "ZMM critical, "; }
							if ($VERBOSITY == 1) {$statusMessage .= "ZMM Module state critical, "; }
							if ($VERBOSITY >= 2) {$statusMessage .= "Zero Maintenance Module error or module not found!, "; }	
						}
					}
				}
			}
		}
		
	}
	return ($status, $statusMessage);
}

# Returns Information about physical Devices attached to the Adaptec Raid-Controller:
#		- Disk Status
#		- S.M.A.R.T. Status
#		- S.M.A.R.T. Warnings
#		- Low-RPM Warnings
#		- Failed Disk Segments
sub getPhysDevCfg {
	my $sudo = $_[0];
	my $arcconf = $_[1];
    my $controller = $_[2];
    my @devices = @{($_[3])};
    my $devicenum = -1;
    my $status = 0; #Return Status
    my $statusMessage = ''; # Return String
    my @faildevices;
    my @output = `$sudo $arcconf GETCONFIG $controller PD`;
    my @linevalues;
    
    foreach my $line (@output) {
        if($line =~ /(Device #)([0-9]+)/) {
        	if(!defined($devices[0])) {
        		$devicenum = $2;
        	} else {
        		if(grep {$_ eq $2} @devices) {
        			$devicenum = $2;
        		} else {
        			$devicenum = -1;
        		}
        	}
        }
        if($devicenum ne -1 && index($line, ':') != -1) {
            @linevalues = split(/:/, $line);
            $linevalues[0] =~ s/^\s+|\s+$//g;
            $linevalues[1] =~ s/^\s+|\s+$//g;

            given($linevalues[0]) {
            	# Main disk status (Online/Offline?)
                when("State") {
                    if ($linevalues[1] ne "Online") {
						#check if device is in failed array, else add it
                    	if(!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY == 0) {$statusMessage .= "Disk offline, "; }
                        if ($VERBOSITY >= 1) {$statusMessage .= "Disk $devicenum is offline, "; }
                    }
                }
            	
            	# Overall S.M.A.R.T. status
                when("S.M.A.R.T.") {
                    if ($linevalues[1] ne "No") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                    	$status = myStatus($status, STATE_CRITICAL);
                    	if ($VERBOSITY == 0) {$statusMessage .= "S.M.A.R.T. critical, "; }
                        if ($VERBOSITY >= 1) {$statusMessage .= "Disk $devicenum: S.M.A.R.T. status critical, "; }
                    }
                }
            	
            	# Check if any S.M.A.R.T. warnings occured
                when("S.M.A.R.T. warnings") {
                    if ($linevalues[1] ne "0") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_WARNING);
                        if ($VERBOSITY == 0) {$statusMessage .= "S.M.A.R.T. warning, "; }
                        if ($VERBOSITY == 1) {$statusMessage .= "Disk $devicenum: S.M.A.R.T. warnings, "; }
                        if ($VERBOSITY >= 2) {$statusMessage .= "Disk $devicenum: \nDisk has one or more S.M.A.R.T. warnings, "; }
                    }
                }
            	
            	# Check if the disk does not run with full (physical) speed
                when("Power state") {
                	if ($linevalues[1] ne "Full rpm") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY == 0) {$statusMessage .= "Low rpm warning, "; }
                        if ($VERBOSITY == 1) {$statusMessage .= "Disk $devicenum does not run with full speed, "; }
                        if ($VERBOSITY >= 2) {$statusMessage .= "Disk $devicenum: \nDisk run in a different power state (not full rpm), "; }
                	}
                }
            	
            	# Look for bad device segments
                when("Failed logical device segments") {
                	if ($linevalues[1] eq "True") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY == 0) {$statusMessage .= "Log. device failed segm, "; }
                        if ($VERBOSITY >= 1) {$statusMessage .= "Disk $devicenum has failed logical device segments, "; }
                	}
                }
            }
        }
    }
    
	# Invalid Logical Device Error
    if ( $devicenum eq -1 ) { 
    	$statusMessage .= "Invalid Log Device, ";
    	myStatus($status, STATE_UNKNOWN); 
    }
    
    # Status output
    my $faildevicenum = scalar(@faildevices);
    if ($VERBOSITY eq 0 && $faildevicenum > 0) {
    	$statusMessage .= "$faildevicenum phys. disk(s) failed, ";
    }

    return ($status, $statusMessage);
}

# Returns Information about logical Devices:
#		- General Logical Devices Status
#		- Failed Stripes
sub getLogDevCfg {
	my $sudo = $_[0];
	my $arcconf = $_[1];
    my $controller = $_[2];
    my @devices = @{($_[3])};
    my $devicenum = -1;
    my $status = 0; #Return status
    my $statusMessage = ''; #Return string
    my @faildevices;
    my @output = `$sudo $arcconf GETCONFIG $controller LD`;
    my @linevalues;
   
    foreach my $line (@output) {
        if($line =~ /(Logical device number )([0-9]+)/) {
        	if(!defined($devices[0])) {
        		$devicenum = $2;
        	} else {
        		if(grep {$_ eq $2} @devices) {
        			$devicenum = $2;
        		} else {
        			$devicenum = -1;
        		}
        	}
        }
        if($devicenum ne -1 && index($line, ':') != -1) {
            @linevalues = split(/:/, $line);
            $linevalues[0] =~ s/^\s+|\s+$//g;
            $linevalues[1] =~ s/^\s+|\s+$//g;

            given($linevalues[0]) {
            
            	# Main logical device status
                when("Status of logical device") {
                    if ($linevalues[1] ne "Optimal") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY == 0) {$statusMessage .= "Log. device critical, "; }
                        if ($VERBOSITY >= 1) {$statusMessage .= "State of logical disk $devicenum critical, "; }
                    }
                }
            	
            	# Check for failed stripes
                when("Failed stripes") {
                    if ($linevalues[1] ne "No") {
                    	if (!grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                    	$status = myStatus($status, STATE_CRITICAL);
                    	if ($VERBOSITY == 0) {$statusMessage .= "Failed stripes, "; }
                        if ($VERBOSITY >= 1) {$statusMessage .= "Logical disk $devicenum has failed stripes, "; }
                    }
                }
            }
        }
    }
    
	# Invalid Logical Device Error
    if ( $devicenum eq -1 ) { 
    	$statusMessage .= "Invalid Log Device, ";
    	myStatus($status, STATE_UNKNOWN); 
    }
	
	# Status Output
    my $faildevicenum = scalar(@faildevices);
    if ($VERBOSITY eq 0 && $faildevicenum > 0) {
    	$statusMessage = "$faildevicenum log. device(s) failed, ";
    }

    return ($status, $statusMessage);
}

MAIN: {
	my $controller = 1;
	my @logDevices; 
	my @physDevices;
	my $sudo; 
	my $arcconf;
	my $platform = $^O;
 	my @temperature;
 	my $zmm = 1;
 	my $statusMessage; # printed status message
	
	if ( !(GetOptions(
		'v|verbose' => sub { $VERBOSITY = 1 },
		'vv' => sub { $VERBOSITY = 2 },
		'vvv' => sub { $VERBOSITY = 3 },
		'h|help' => sub {displayHelp();},
		'V|version' => sub {displayVersion($sudo, $arcconf);},
		'C|controller=i' => \$controller,
		'LD|logicaldevice=s' => \@logDevices,
		'PD|physicaldevice=s' => \@physDevices, 
		'T|temperature=s' => \@temperature,
		'p|path=s' => \$arcconf,
		'z|ZMM=i' => \$zmm
	)))	{
		print $NAME . " Version: " . $VERSION ."\n";
		displayUsage();
		exit(STATE_UNKNOWN);
	}
	
	@logDevices = split(/,/,join(',', @logDevices));
	@physDevices = split(/,/,join(',', @physDevices));
	if (!@temperature) {
		@temperature = (50,60);
	}
	else{
		@temperature = split(/,/,join(',', @temperature));
	}
	
	# Check platform
	if ($platform eq 'linux') {
		chomp($sudo= `/usr/bin/sudo`);
		if (!$arcconf) {
			$arcconf = '/usr/bin/arcconf';
		}
		unless ( -e $arcconf && -x $sudo ) {
			print "Permission denied or file not found!\n";
			exit(STATE_UNKNOWN);
		}
	} else {
		$sudo = '';
		if (!$arcconf) {
			$arcconf = 'C:\Programme\Adaptec\RemoteArcconf\arcconf.exe';
		}
		unless ( -e $arcconf ) { print "Executable not found!\n"; exit(STATE_UNKNOWN); }
	}
	
 	# Input validation
 	my @controllerVersion = `$sudo $arcconf GETVERSION $controller`;
 	if($controllerVersion[1] eq "Invalid controller number.") {
 		print "Invalid controller number, device not found!";
 		exit(STATE_UNKNOWN);
 	}
	if(!$zmm =~ /(^[0-1]+)/) {
 		print "Invalid ZMM parameter, must be 0 or 1!";
		exit(STATE_UNKNOWN);
	}	

	# Set exit status
	my $newExitStatus = 0;
	my $newStatusMessage = '';
	($newExitStatus, $statusMessage) = getControllerCfg($sudo, $arcconf, $controller, \@temperature, $zmm);
	$newStatusMessage .= $statusMessage;
	$EXITSTATUS = myStatus($newExitStatus, $EXITSTATUS);
	($newExitStatus, $statusMessage) = getPhysDevCfg($sudo, $arcconf, $controller, \@physDevices);
	$newStatusMessage .= $statusMessage;
	$EXITSTATUS = myStatus($newExitStatus, $EXITSTATUS);
	($newExitStatus, $statusMessage) = getLogDevCfg($sudo, $arcconf, $controller, \@logDevices);
	$newStatusMessage .= $statusMessage;
	$EXITSTATUS = myStatus($newExitStatus, $EXITSTATUS);
	given($EXITSTATUS) {
		when(0) { print "AACRAID OK (Ctrl #$controller)\n"; }
		when(1) { if($VERBOSITY eq 0) { chop($newStatusMessage); chop($newStatusMessage); } print "AACRAID WARNING (Ctrl #$controller): [$newStatusMessage]\n"; }
		when(2) { if($VERBOSITY eq 0) { chop($newStatusMessage); chop($newStatusMessage); } print "AACRAID CRITICAL (Ctrl #$controller): [$newStatusMessage]\n"; }
	}
	exit($EXITSTATUS);
}