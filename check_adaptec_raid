#!/usr/bin/perl -w
# ==============================================================================
# check_adaptec_raid: Nagios/Icinga plugin to check Adaptec Raid Controller
# status
# ------------------------------------------------------------------------------
# Copyright (c) 2013-2015:
#   Georg Schoenberger  (gschoenberger@thomas-krenn.com)
#   Grubhofer Martin    (s1110239013@students.fh-hagenberg.at)
#   Franz Nemeth
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, see <http://www.gnu.org/licenses/>.
# ==============================================================================
use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
use File::Which;

our $VERBOSITY = 0;
our $VERSION = '2.0';
our $NAME = "check_adaptec_raid: Nagios/Icinga plugin to check Adaptec Raid Controller status";
our $C_TEMP_WARNING = 80;
our $C_TEMP_CRITICAL = 90;
our $PD_TEMP_WARNING = 40;
our $PD_TEMP_CRITICAL = 45;
our $ZMM_TEMP_WARNING = 60;
our $ZMM_TEMP_CRITICAL = 75;
our $CONTROLLER = 1;
our $EXITSTATUS = 0;

use constant {
	STATE_OK => 0,
	STATE_WARNING => 1,
	STATE_CRITICAL => 2,
	STATE_UNKNOWN => 3,
};

# Returns StatusCode 0,1,2,3
sub myStatus {
	my $prevStatus = $_[0];
	my $nextStatus = $_[1];
	my $returnStatus = STATE_OK;
	if($prevStatus >= $nextStatus) {
		$returnStatus = $prevStatus;
	} else {
		$returnStatus = $nextStatus;
	}

	return $returnStatus;
}

# Explains the Usage of the plugin, also which options take which values
sub displayUsage {
	print "Usage: \n";
	print "  [ -C <Controller number> ] [ -LD <Logical device number> ]\n";
	print "  [ -PD <Physical device number> ] [ -T <Warning Temp., Crit. Temp.> ]\n";
	print "  [ -h | --help ]\n	Display this help page\n";
	print "  [ -v | -vv | -vvv | --verbose ]\n	Sets the verbosity level\n	no -v single line output for Nagios/Icinga\n	-v   single line with more details\n	-vv  multiline output for debugging errors and more detailed information\n	-vvv is for plugin problem diagnosis\n";
	print "  [ -V --version ]\n	Displays the Version of the tk-adaptec-plugin and the version of arcconf\n";
	print "  [ -C <Controller Number> | --controller <Controller Number> ]\n	Specifies a Controller number, (Default 1).\n";
	print "  [ -LD | --logicaldevice <Log. device number> ]\n	Specifies one or more Logical Devices to monitor.\n	Accepts a positive Integer or a comma seperated list as additional argument\n	(Default all)\n";
	print "  [ -PD | --physicaldevice <Phys. device number> ]\n	Specifies one or more Physical Devices to monitor.\n	Accepts a positive Integer or a comma seperated list as additional argument\n	(Default all)\n";
	print "  [ -Tw | --temperature-warn ]\n	Specifies the RAID-Controller temperature warning range, default is 70 C or more.\n";
	print "  [ -Tc | --temperature-crit ]\n	Specifies the RAID-Controller temperature critical error range, default is 75 C or more.
	Requires Temperature Warning [-Tw|--temperature-warning] to be set.\n";
	print "  [ -p <path> | --path <path>]\n	Specifies the path to arcconf.\n	Default is /usr/bin/arcconf  C:\\Programme\\Adaptec\\RemoteArcconf\\arcconf.exe\n";
	print "  [ -z <0/1> | ZMM <0/1> ]\n	Boolean Value which specifies if a Zero-Maintenance Module is available\n	(1 is available, 0 is not available). (Default 1)\n	This option is required if you have an Adaptec Raid Controller without a ZMM.\n\n";
}

# Displays a short Help text for the user
sub displayHelp {
	print $NAME . " Version: " . $VERSION ."\n";
	print "Copyright (C) 2009-2013 Thomas-Krenn.AG\n";
	print "Current updates available via git at:\n  http://git.thomas-krenn.com/check_adaptec_raid.git\n";
	print "This Nagios/Icinga Plugin checks ADAPTEC RAID-Controllers for Controller, \nPhysical-Device and Logical Device warnings and errors. \n";
	print "In order for this plugin to work properly you need to add the \nnagios-user to your sudoers file (or create a new one in /etc/sudoers.d/).\n";
	print "This is required as arcconf must be called with sudo permissions.\n";
	displayUsage();
	print "Further information about this plugin can be found at:
  http://www.thomas-krenn.com/de/wiki/Adaptec_RAID_Monitoring_Plugin and
  http://www.thomas-krenn.com/de/wiki/Adaptec_RAID_Monitoring_Plugin
Please send an email to the tk-monitoring plugin-user mailing list:
  tk-monitoring-plugins-user\@lists.thomas-krenn.com
if you have questions regarding the use of this software, to submit patches, or
suggest improvements. The mailing list archive is available at:
  http://lists.thomas-krenn.com/pipermail/tk-monitoring-plugins-user\n";
	exit(STATE_UNKNOWN);
}

# Prints the name and the version of check_adaptec_raid. If arcconf is
# available, the version of it is printed also.
# @param arcconf The path to arcconf command utility
sub displayVersion {
	my $arcconf = shift;
	if(defined($arcconf)){
		my @arcconfVersion = `$arcconf`;
		print "arcconf version:\n";
		print grep /Version/, @arcconfVersion;
	}
	exit(STATE_OK);
}

# Checks if an arcconf call was successfull, i.e. if the return code is 0
# and 'invalid' is not present in the second line
# @param output The output of the arcconf command as array
# @param returnCode The return code of the arcconf call
# @return 1 on success, 0 if not
sub checkCommandStatus{
	my @output = @{(shift)};
	my $returnCode = shift;
	if(($output[1] =~ /^Invalid/) || (($returnCode >> 8) != 0)){
		return 0;
	}
	else{
		return 1;
	}
}

# Shows the version information about a controller. Can be used to check if the
# controller number is a correct one.
# @param arcconf The path to arcconf command utility
# @return 1 on success, 0 if not
sub getControllerVersion{
	my $arcconf = shift;
	my @output = `$arcconf GETVERSION $CONTROLLER`;
	return (checkCommandStatus(\@output, $?));
}

# Implementation from check_LSI_raid
# Uses correct Nagios Threshold implementation
# Nagios development guidelines: temperature threshold sheme
# http://nagiosplug.sourceforge.net/developer-guidelines.html#THRESHOLDFORMAT
# Returns a temperature range (array) in or out which a temperature should be
# Array content: ("in" or "out", range from, range to)
# Example ranges:
#				Generate an alert if x...
#	-Tw 10			< 0 or > 10, (outside the range of {0 .. 10})
#	-Tw 10:			< 10, (outside {10 .. inf})
#	-Tw ~:10		> 10, (outside the range of {-inf .. 10})
#	-Tw 10:20		< 10 or > 20, (outside the range of {10 .. 20})
#	-Tw @10:20		>= 10 and <= 20, (inside the range of {10 .. 20})
sub getThresholds {
	my @thresholds = @{($_[0])};
	my $default = $_[1];

	if(scalar(@thresholds) eq 0) {
		return @thresholds = ("out", 0, $default);
	}
	if(substr($thresholds[0], 0, 1) eq "@") {
		if($thresholds[0] =~ /^\@([0-9]*)\:([0-9]*)$/) {
			@thresholds = ("in", $1, $2);
		} else {
			print "Invalid temperature parameter!";
			exit(STATE_UNKNOWN);
		}
	} elsif(substr($thresholds[0], 0, 1) eq "~") {
		if($thresholds[0] =~ /^\~\:([0-9]*)$/) {
			@thresholds = ("out", 0, $1);
		} else {
			print "Invalid temperature parameter!";
			exit(STATE_UNKNOWN);
		}
	} elsif(index($thresholds[0], ":") ne -1) {
		if($thresholds[0] =~ /^([0-9]*)\:([0-9]{1,3})$/) {
			@thresholds = ("out", $1, $2);
		} elsif($thresholds[0] =~ /^([0-9]*)\:$/) {
			@thresholds = ("in", 0, ($1 - 1));
		} else {
			print "Invalid temperature parameter!";
			exit(STATE_UNKNOWN);
		}
	} else {
		@thresholds = ("out", 0, $thresholds[0]);
	}
	if(($thresholds[1] =~ /^(-?[0-9]*)$/) && ($thresholds[2] =~ /^(-?[0-9]*)$/)) {
		return @thresholds;
	} else {
		print "Invalid temperature parameter!";
		exit(STATE_UNKNOWN);
	}
}


# Returns Information about the Adaptec RAID-Controller itsself:
#		- Controller Status
#		- Defunctional Disks
#		- Logical Devices which have failed/are degraded
#		- Temperature
# 		- Status of ZMM if present
sub getControllerCfg {
	my $sudo = $_[0];
	my $arcconf = $_[1];
	my $controller = $_[2];
	my @temperature_w = @{($_[3])};
	my @temperature_c = @{($_[4])};
	my $zmm = $_[5];
	my $status = 0; # Return Status
	my $statusMessage = ''; # Return String
	my @output = `$sudo $arcconf GETCONFIG $controller AD`;
	my @linevalues;

	if(!defined($output[0]) || ($output[0] eq "Controllers found: 0\n") ||
	!defined($output[1]) || ($output[1] eq "Invalid controller number.\n")) {
		print "Invalid controller number or no controller found!\n";
		exit(STATE_UNKNOWN);
	}

	foreach my $line (@output) {
		if(index($line, ':') != -1) {
			@linevalues = split(/:/, $line);
			$linevalues[0] =~ s/^\s+|\s+$//g;
			$linevalues[1] =~ s/^\s+|\s+$//g;

			# Overall Controller Status
			if(($linevalues[0] eq "Controller Status") && ($linevalues[1] ne "Optimal")) {
				$status = myStatus($status, STATE_CRITICAL);
				if($VERBOSITY == 0) {$statusMessage .= "Ctrl. Status critical, "; }
				if($VERBOSITY == 1) {$statusMessage .= "Controller Status is critical, "; }
				if($VERBOSITY >= 2) {$statusMessage .= "The Controller Status is not running Optimal, "; }
			}
			# Defunctional disks
			if(($linevalues[0] eq "Defunct disk drive count") && ($linevalues[1] ne "0")) {
				$status = myStatus($status, STATE_CRITICAL);
				if($VERBOSITY == 0) {$statusMessage .= "Defunct. disks, "; }
				if($VERBOSITY >= 1) {$statusMessage .= $linevalues[1] . " disks are defunctional, "; }
			}

			# Logical Devices total/failed/degraded
			# Warning since the raid is still recoverable, if it isnt you wont need a nagios plugin to notice that!
			if($linevalues[0] eq "Logical devices/Failed/Degraded") {
				$linevalues[1] =~ /([0-9]+)\/([0-9]+)\/([0-9]+)/;
				my $totalDisks = $1;
				my $totalFailed = $2;
				my $totalDegraded = $3;
				if($totalFailed ne '0' || $totalDegraded ne '0') {
					$status = myStatus($status, STATE_WARNING);
					if($VERBOSITY == 0) {$statusMessage .= "Log. device failed/degraded, "; }
					if($VERBOSITY == 1) {$statusMessage .= "Logical devices have failed or are degraded, "; }
					if($VERBOSITY == 2) {$statusMessage .= "Disks have failed or the Raid is degraded, "; }
					if($VERBOSITY == 3) {$statusMessage .= "Disks have failed or the Raid is degraded: (Total Disks: ". $totalDisks . ", Failed: " . $totalFailed . ", Degraded: " . $totalDegraded . "), "; }
				}
			}

			# Warning if temperature is over the set Threshold
			if($linevalues[0] eq "Temperature") {
				my $crit = 0;
				if(!@temperature_c) { $temperature_c[1] = '0'; $temperature_c[2] = '0' }
				if(!@temperature_w) { $temperature_w[1] = '0'; $temperature_w[2] = '0' }
				my ($controllerTemp) = $linevalues[1] =~ /(^[0-9]+)/;
				if($temperature_w[0] eq "in") {
					if(($controllerTemp >= $temperature_w[1]) && ($controllerTemp <= $temperature_w[2])) {
						if(($temperature_c[0] eq "in") && ($controllerTemp >= $temperature_c[1]) && ($controllerTemp <= $temperature_c[2])) {
							$crit = 1;
							$status = myStatus($status, STATE_CRITICAL);
							if($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. critical, "; }
							if($VERBOSITY == 1) {$statusMessage .= "Temperature critical: " . $controllerTemp . " C, "; }
							if($VERBOSITY == 2) {$statusMessage .= "Temperature critical: ". $controllerTemp . " C, "; }
							if($VERBOSITY == 3) {$statusMessage .= "Temperature critical (Threshold: ".$temperature_c[1]." ,".$temperature_c[2]." C):".$controllerTemp." C, "; }
						} elsif(($controllerTemp < $temperature_c[1]) || ($controllerTemp > $temperature_c[2])) {
							$crit = 1;
							$status = myStatus($status, STATE_CRITICAL);
							if($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. critical, "; }
							if($VERBOSITY == 1) {$statusMessage .= "Temperature critical: " . $controllerTemp . " C, "; }
							if($VERBOSITY == 2) {$statusMessage .= "Temperature critical: ". $controllerTemp . " C, "; }
							if($VERBOSITY == 3) {$statusMessage .= "Temperature critical (Threshold: ".$temperature_c[1].", ".$temperature_c[2]." C):".$controllerTemp." C, "; }
						}
						if($crit eq "0") {
							$status = myStatus($status, STATE_WARNING);
							if($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. warning, "; }
							if($VERBOSITY == 1) {$statusMessage .= "Temperature Warning: ".$controllerTemp." C, "; }
							if($VERBOSITY == 2) {$statusMessage .= "Temperature Warning (Threshold: ".$temperature_w[1].", ".$temperature_w[2]." C): ".$controllerTemp." C,"; }
							if($VERBOSITY == 3) {$statusMessage .= "Temperature Warning (Threshold: ".$temperature_w[1].", ".$temperature_w[2].", Critical Threshold: ".$temperature_c[1].", ".$temperature_c[2]." C):".$controllerTemp." C, "; }
						}
					}
				} else {
					if(($controllerTemp < $temperature_w[1]) || ($controllerTemp > $temperature_w[2])) {
						if(($temperature_c[0] eq "in") && ($controllerTemp >= $temperature_c[1]) && ($controllerTemp <= $temperature_c[2])){
							$crit = 1;
							$status = myStatus($status, STATE_CRITICAL);
							if($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. critical, "; }
							if($VERBOSITY == 1) {$statusMessage .= "Temperature critical: " . $controllerTemp . " C, "; }
							if($VERBOSITY == 2) {$statusMessage .= "Temperature critical: ". $controllerTemp . " C, "; }
							if($VERBOSITY == 3) {$statusMessage .= "Temperature critical (Threshold: ". $temperature_c[1]. ", ". $temperature_c[2] . " C):" . $controllerTemp . " C, "; }

						} else {
							if(($controllerTemp < $temperature_c[1]) || ($controllerTemp > $temperature_c[2])) {
								$crit = 1;
								$status = myStatus($status, STATE_CRITICAL);
								if($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. critical, "; }
								if($VERBOSITY == 1) {$statusMessage .= "Temperature critical: " . $controllerTemp . " C, "; }
								if($VERBOSITY == 2) {$statusMessage .= "Temperature critical: ". $controllerTemp . " C, "; }
								if($VERBOSITY == 3) {$statusMessage .= "Temperature critical (Threshold: ". $temperature_c[1]. ", ". $temperature_c[2] . " C):" . $controllerTemp . " C, "; }
							}
						}
						if($crit eq "0") {
							$status = myStatus($status, STATE_WARNING);
							if($VERBOSITY == 0) {$statusMessage .= "Ctrl. temp. warning, "; }
							if($VERBOSITY == 1) {$statusMessage .= "Temperature Warning: " . $controllerTemp . " C, "; }
							if($VERBOSITY == 2) {$statusMessage .= "Temperature Warning (Threshold: ". $temperature_w[1] . ", " . $temperature_w[2]. " C): " . $controllerTemp . " C,"; }
							if($VERBOSITY == 3) {$statusMessage .= "Temperature Warning (Threshold: ". $temperature_w[1] . ", " . $temperature_w[2]. ", Critical Threshold: ". $temperature_c[1] . ", " . $temperature_c[2] ." C):" . $controllerTemp . " C, "; }
						}
					}
				}
			}
			# Zero Maintenance Module
			if(($zmm eq 1) && ($linevalues[0] eq "Status") && ($linevalues[1] ne "ZMM Optimal")) {
				$status = myStatus($status, STATE_CRITICAL);
				if($VERBOSITY == 0) {$statusMessage .= "ZMM critical, "; }
				if($VERBOSITY == 1) {$statusMessage .= "ZMM Module state critical, "; }
				if($VERBOSITY >= 2) {$statusMessage .= "Zero Maintenance Module error or module not found!, "; }
			}
		}

	}
	return ($status, $statusMessage);
}

# Returns Information about physical Devices attached to the Adaptec Raid-Controller:
#		- Disk Status
#		- S.M.A.R.T. Status
#		- S.M.A.R.T. Warnings
#		- Low-RPM Warnings
#		- Failed Disk Segments
sub getPhysDevCfg {
	my $sudo = $_[0];
	my $arcconf = $_[1];
	my $controller = $_[2];
	my $devices = $_[3];
	my $statusMessage = ''; # Return String
	my @output = `$sudo $arcconf GETCONFIG $controller PD`;
	my (@faildevices, @linevalues);
	my $status = 0; # Return Code
	
	# Get a sorted list of user defined numbers and define
	# a hash to check if current PD is in user PDs
	my @userPD_a;
	my %userPD_h;
	if(defined($devices)) {
		@userPD_a = split(/,/, join(',',$devices));
		%userPD_h = map {$_ => 1} @userPD_a;
	}

	my $deviceToCheck;
	my $devicesChecked = 0;
	foreach my $line (@output) {
		if($line =~ /(Device #)([0-9]+)/) {
			$deviceToCheck = $2;
			$devicesChecked++;
		}
		# Skip lines as long we don't have a device to check
		next if(!defined($deviceToCheck));
		# If array has elements but key doesn't exist, skip PD
		if(defined($deviceToCheck) && @userPD_a && !(exists $userPD_h{$deviceToCheck})){
			$devicesChecked--;
			undef $deviceToCheck;
			next;
		}
		# Skip PD if it is a backplane 
		if(defined($deviceToCheck) && ($line =~ /Device is an Enclosure services device/)) {
			$devicesChecked--;
			undef $deviceToCheck;
			next;
		}
		# Linesplitting and removing spaces
		if(defined($deviceToCheck) && index($line, ':') != -1){
			@linevalues = split(/:/, $line);
			$linevalues[0] =~ s/^\s+|\s+$//g;
			$linevalues[1] =~ s/^\s+|\s+$//g;
			# Main disk status (Online/Offline?)
			if(($linevalues[0] eq "State") && !($linevalues[1] =~ /^(Online|Global Hot-Spare|Dedicated Hot-Spare|Hot Spare|Ready|Online \(JBOD\))$/)) {
				# check if device is in failed array, else add it
				if(!grep {$_ eq $deviceToCheck} @faildevices) {
					push(@faildevices, $deviceToCheck);
				}
				$status = myStatus($status, STATE_CRITICAL);
				if($VERBOSITY == 0) {$statusMessage .= "Disk offline, "; }
				if($VERBOSITY >= 1) {$statusMessage .= "Disk $deviceToCheck is offline, "; }
			}
			# Overall S.M.A.R.T. status
			elsif(($linevalues[0] eq "S.M.A.R.T.") && ($linevalues[1] ne "No")) {
				if(!grep {$_ eq $deviceToCheck} @faildevices) {
					push(@faildevices, $deviceToCheck);
				}
				$status = myStatus($status, STATE_CRITICAL);
				if($VERBOSITY == 0) {$statusMessage .= "S.M.A.R.T. critical, "; }
				if($VERBOSITY >= 1) {$statusMessage .= "Disk $deviceToCheck: S.M.A.R.T. status critical, "; }
			}
			# Check if any S.M.A.R.T. warnings occured
			elsif(($linevalues[0] eq "S.M.A.R.T. warnings") && ($linevalues[1] ne "0")){
				if(!grep {$_ eq $deviceToCheck} @faildevices) {
					push(@faildevices, $deviceToCheck);
				}
				$status = myStatus($status, STATE_WARNING);
				if($VERBOSITY == 0) {$statusMessage .= "S.M.A.R.T. warning, "; }
				if($VERBOSITY == 1) {$statusMessage .= "Disk $deviceToCheck: S.M.A.R.T. warnings, "; }
				if($VERBOSITY >= 2) {$statusMessage .= "Disk $deviceToCheck: Disk has one or more S.M.A.R.T. warnings, "; }
			}
			# Check if the disk does not run with full (physical) speed
			elsif(($linevalues[0] eq "Power State") && ($linevalues[1] ne "Full rpm")){
				if(!grep {$_ eq $deviceToCheck} @faildevices) {
					push(@faildevices, $deviceToCheck);
				}
				$status = myStatus($status, STATE_CRITICAL);
				if($VERBOSITY == 0) {$statusMessage .= "Low rpm warning, "; }
				if($VERBOSITY == 1) {$statusMessage .= "Disk $deviceToCheck does not run with full speed, "; }
				if($VERBOSITY >= 2) {$statusMessage .= "Disk $deviceToCheck: \nDisk run in a different power state (not full rpm), "; }
			}
			# Look for bad device segments
			elsif(($linevalues[0] eq "Failed logical device segments") && ($linevalues[1] ne "False")){
				if(!grep {$_ eq $deviceToCheck} @faildevices) {
					push(@faildevices, $deviceToCheck);
				}
				$status = myStatus($status, STATE_CRITICAL);
				if($VERBOSITY == 0) {$statusMessage .= "Log. device failed segm, "; }
				if($VERBOSITY >= 1) {$statusMessage .= "Disk $deviceToCheck has failed logical device segments, "; }
			}
		}
	}
	if(defined($devices) && $devicesChecked ne scalar(@userPD_a)) {
		print "Invalid Physical Devices specified or one is a service device!\n";
		exit(STATE_UNKNOWN);
	}
	# Status output
	my $faildevicenum = scalar(@faildevices);
	if($VERBOSITY >= 0 && $faildevicenum > 0) {
		$statusMessage .= "$faildevicenum phys. disk(s) failed, ";
	}

	return ($status, $statusMessage);
}

# Returns Information about logical Devices:
#		- General Logical Devices Status
#		- Failed Stripes
sub getLogDevCfg {
	my $sudo = $_[0];
	my $arcconf = $_[1];
	my $controller = $_[2];
	my $devices = $_[3];
	my $devicenum = -1;
	my $status = 0; #Return status
	my $statusMessage = ''; #Return string
	my @faildevices;
	my @output = `$sudo $arcconf GETCONFIG $controller LD`;
	my @linevalues;

	# Get a sorted list of user defined numbers and define
	# a hash to check if current PD is in user PDs
	my @userLD_a;
	my %userLD_h;
	if(defined($devices)) {
		@userLD_a = split(/,/, join(',', $devices));
		%userLD_h = map {$_ => 1} @userLD_a;
	}

	my $ldToCheck;
	my $ldChecked = 0;
	foreach my $line (@output) {
		if($line =~ /(Logical device number )([0-9]+)/) {
			$ldToCheck = $2;
			$devicenum = $2;
			$ldChecked++;
		}
		
		# Skip lines as long we don't have a device to check
		next if(!defined($ldToCheck));
		# If array has elements but key doesn't exist, skip LD
		if(defined($ldToCheck) && @userLD_a && !(exists $userLD_h{$ldToCheck})) {
			$ldChecked--;
			undef $ldToCheck;
			next;
		}
		# Linesplitting and removing spaces
		if(defined($ldToCheck) && index($line, ':') != -1) {
			@linevalues = split(/:/, $line);
			$linevalues[0] =~ s/^\s+|\s+$//g;
			$linevalues[1] =~ s/^\s+|\s+$//g;
			# Main logical device status
			if(($linevalues[0] eq "Status of logical device") && ($linevalues[1] ne "Optimal")) {
				if(!grep {$_ eq $devicenum} @faildevices) {
					push(@faildevices, $devicenum);
				}
				$status = myStatus($status, STATE_CRITICAL);
				if($VERBOSITY == 0) {$statusMessage .= "Log. device critical, "; }
				if($VERBOSITY >= 1) {$statusMessage .= "State of logical disk $devicenum critical, "; }
			}
			# Check for failed stripes
			elsif(($linevalues[0] eq "Failed stripes") && ($linevalues[1] ne "No")) {
				if(!grep {$_ eq $devicenum} @faildevices) {
					push(@faildevices, $devicenum);
				}
				$status = myStatus($status, STATE_CRITICAL);
				if($VERBOSITY == 0) {$statusMessage .= "Failed stripes, "; }
				if($VERBOSITY >= 1) {$statusMessage .= "Logical disk $devicenum has failed stripes, "; }
			}
		}
	}

	# Invalid Logical Device Error
	if(defined($devices) && $ldChecked != scalar(@userLD_a)){
		print "Invalid Logical Devices specified!\n";
		exit(STATE_UNKNOWN);
	}
	# Status Output
	my $faildevicenum = scalar(@faildevices);
	if($VERBOSITY >= 0 && $faildevicenum > 0) {
		$statusMessage .= "$faildevicenum log. device(s) failed, ";
	}
	return ($status, $statusMessage);
}

# Checks the status of the ZMM, parses 'GETCONFIG AD' for the given
# controller.
# @param arcconf The path to arcconf command utility
# @param statusLevel_a The status level array, elem 0 is the current status,
# elem 1 the warning sensors, elem 2 the critical sensors, elem 3 the verbose
# information for the sensors.
# @param commands_a An array to push the used command to
sub getZMMStatus {
	my $arcconf = shift;
	my @statusLevel_a = @{(shift)};
	my $commands_a = shift;
	
	my $command = "$arcconf GETCONFIG $CONTROLLER AD";
	push @{$commands_a}, $command;

	my $status;
	my @output = `$command`;
	if(checkCommandStatus(\@output, $?)) {
		my $currBlock;
		my %foundZMM_h;
		foreach my $line (@output) {
			$line =~ s/^\s+|\s+$//g;
			if($line =~ /^(Controller Cache Backup)/){
				$currBlock = $1;
				next;
			}
			if(defined($currBlock)){
				if($line =~ /\:/){
					my @lineVals = split(':', $line);
					$lineVals[0] =~ s/^\s+|\s+$//g;
					$lineVals[1] =~ s/^\s+|\s+$//g;
					$foundZMM_h{$lineVals[0]} = $lineVals[1];
				}
			}
		}
		if(exists($foundZMM_h{'Overall Backup Unit Status'})){
			if($foundZMM_h{'Overall Backup Unit Status'} ne 'Ready'){
				$status = 'Warning';
				push @{$statusLevel_a[1]}, 'ZMM_State';
				$statusLevel_a[3]->{'ZMM_State'} = $foundZMM_h{'Overall Backup Unit Status'};
			}
		}
		if(exists($foundZMM_h{'Non-Volatile Storage Status'})){
			if($foundZMM_h{'Non-Volatile Storage Status'} ne 'Ready'){
				$status = 'Warning';
				push @{$statusLevel_a[1]}, 'ZMM_NVS_Status';
				$statusLevel_a[3]->{'ZMM_NVS_Status'} = $foundZMM_h{'Non-Volatile Storage Status'};
			}
		}
		if(exists($foundZMM_h{'Supercap Status'})){
			if($foundZMM_h{'Supercap Status'} ne 'Ready'){
				$status = 'Warning';
				push @{$statusLevel_a[1]}, 'ZMM_SCap_Status';
				$statusLevel_a[3]->{'ZMM_SCap_Status'} = $foundZMM_h{'Supercap Status'};
			}
		}
		if(exists($foundZMM_h{'Current Temperature'})){
			$foundZMM_h{'Current Temperature'} =~ /([0-9]+) deg C$/;
			if(!(checkThreshs($1, $ZMM_TEMP_CRITICAL))){
				$status = 'Critical';
				push @{$statusLevel_a[2]}, 'ZMM_Temperature';
			}
			elsif(!(checkThreshs($1, $ZMM_TEMP_WARNING))){
				$status = 'Warning';
				push @{$statusLevel_a[1]}, 'ZMM_Temperature';
			}
			$statusLevel_a[3]->{'ZMM_Temperature'} = $1;
		}
		if(exists($foundZMM_h{'Voltage(Present/Max)'})){
			$foundZMM_h{'Voltage(Present/Max)'} =~ /(^[0-9]+) mV/;
			$statusLevel_a[3]->{'ZMM_Voltage_Present'} = $1;
		}
		if(exists($foundZMM_h{'Health'})){
			$foundZMM_h{'Health'} =~ /(^[0-9]+) percent/;
			$statusLevel_a[3]->{'ZMM_Health'} = $1;
		}
		if(exists($foundZMM_h{'Charge Level'})){
			$foundZMM_h{'Charge Level'} =~ /(^[0-9]+) percent/;
			$statusLevel_a[3]->{'ZMM_Charge_Level'} = $1;
		}
		if(defined($status)){
			if($status eq 'Warning'){
				if(${$statusLevel_a[0]} ne 'Critical'){
					${$statusLevel_a[0]} = 'Warning';
				}
			}
			else{
				${$statusLevel_a[0]} = 'Critical';
			}
			$statusLevel_a[3]->{'ZMM_Status'} = $status;
		}
		else{
			$statusLevel_a[3]->{'ZMM_Status'} = 'OK';
		}
	}
	else {
		print "Invalid arcconf command! ($command)\n";
		exit(STATE_UNKNOWN);
	}
}

# Checks if a ZMM is present
# @param arcconf The path to arcconf command utility
# @return 1 if present, 0 if not
sub checkZMMPresent{
	my $arcconf = shift;
	my $failed = 0;
	my @output = `$arcconf GETCONFIG $CONTROLLER AD`;
	if(checkCommandStatus(\@output, $?)){
		$failed = grep /ZMM Failed/, @output;
	}
	if($failed){
		return 0;
	}
	else{ return 1; }
}

# Checks if a given value is in a specified range, the range must follow the
# nagios development guidelines:
# http://nagiosplug.sourceforge.net/developer-guidelines.html#THRESHOLDFORMAT
# @param value The given value to check the pattern for
# @param pattern The pattern specifying the threshold range, e.g. '10:', '@10:20'
# @return 0 if the value is outside the range, 1 if the value satisfies the range
sub checkThreshs{
	my $value = shift;
	my $pattern = shift;
	if($pattern =~ /(^[0-9]+$)/){
		if($value < 0 || $value > $1){
			return 0;
		}
	}
	elsif($pattern =~ /(^[0-9]+)\:$/){
		if($value < $1){
			return 0;
		}
	}
	elsif($pattern =~ /^\~\:([0-9]+)$/){
		if($value > $1){
			return 0;
		}
	}
	elsif($pattern =~ /^([0-9]+)\:([0-9]+)$/){
		if($value < $1 || $value > $2){
			return 0;
		}
	}
	elsif($pattern =~ /^\@([0-9]+)\:([0-9]+)$/){
		if($value >= $1 and $value <= $2){
			return 0;
		}
	}
	else{
		print "Invalid temperature parameter! ($pattern)\n";
		exit(STATE_UNKNOWN);
	}
	return 1;
}

MAIN: {
	my ($arcconf, $sudo, $noSudo, $version, $exitCode);
	# Create default sensor arrays and push them to status level
	my @statusLevel_a ;
	my $status_str = 'OK';
	my $warnings_a = [];
	my $criticals_a = [];
	my $verboseValues_h = {};
	my $verboseCommands_a = [];
	push @statusLevel_a, \$status_str;
	push @statusLevel_a, $warnings_a;
	push @statusLevel_a, $criticals_a;
	push @statusLevel_a, $verboseValues_h;
	push @statusLevel_a, $verboseCommands_a;
	# Per default use a ZMM
	my $zmm = 1;
	my @logDevices;
	my @physDevices;
	my $platform = $^O;

	if( !(GetOptions(
		'h|help' => sub {displayHelp();},
		'v|verbose' => sub {$VERBOSITY = 1 },
		'vv' => sub {$VERBOSITY = 2},
		'vvv' => sub {$VERBOSITY = 3},
		'V|version' => \$version,
		'C|controller=i' => \$CONTROLLER,
		'LD|logicaldevice=s' => \@logDevices,
		'PD|physicaldevice=s' => \@physDevices,
		'Tw|temperature-warn=s' => \$C_TEMP_WARNING,
		'Tc|temperature-critical=s' => \$C_TEMP_CRITICAL,
		'PDTw|physicaldevicetemperature-warn=s' => \$PD_TEMP_WARNING,
		'PDTc|physicaldevicetemperature-critical=s' => \$PD_TEMP_CRITICAL,
		'p|path=s' => \$arcconf,
		'z|ZMM=i' => \$zmm,
		'nosudo' => \$noSudo,
	))){
		print $NAME . " Version: " . $VERSION ."\n";
		displayUsage();
		exit(STATE_UNKNOWN);
	}
	if(defined($version)){ print $NAME . "\nVersion: ". $VERSION . "\n"; }
	# Check arcconf tool
	if(!defined($arcconf)){
		if($platform eq 'linux'){
			$arcconf = which('arcconf');
		}
		else{
			$arcconf = which('arcconf.exe');
		}
	}
	if(!defined($arcconf)){
		print "Error: cannot find arcconf executable.\n";
		print "Ensure arcconf is in your path, or use the '-p <arcconf path>' switch!\n";
		exit(STATE_UNKNOWN);
	}
	if($platform eq 'linux') {
		if(!defined($noSudo)){
			my $sudo;
			chomp($sudo = `which sudo`);
			if(!defined($sudo)){
				print "Error: cannot find sudo executable.\n";
				exit(STATE_UNKNOWN);
			}
			$arcconf = $sudo.' '.$arcconf;
		}
	}
	# Print arcconf version if available
	if(defined($version)){ displayVersion($arcconf) }
	# Check if the controller number can be used
	if(!getControllerVersion($arcconf)){
		print "Error: invalid controller number, controller not found!\n";
		exit(STATE_UNKNOWN);
	}
	# Prepare command line arrays
	@logDevices = split(/,/,join(',', @logDevices));
	@physDevices = split(/,/,join(',', @physDevices));
	# Check if the BBU param is correct
	if(($zmm != 1) && ($zmm != 0)) {
		print "Error: invalid ZMM parameter, must be 0 or 1!\n";
		exit(STATE_UNKNOWN);
	}
	my $zmmPresent = 0;
	if($zmm == 1){
		$zmmPresent = checkZMMPresent($arcconf);
		if($zmmPresent == 0){
			${$statusLevel_a[0]} = 'Critical';
			push @{$criticals_a}, 'ZMM_Present';
			$statusLevel_a[3]->{'ZMM_Status'} = 'Critical';
		}
	}
	if($zmmPresent == 1){getZMMStatus($arcconf, \@statusLevel_a, $verboseCommands_a); }
	use Data::Dumper;
	print Dumper($statusLevel_a[3]);
#	# check given thresholds
#	if(@temperature_c && !@temperature_w){
#		print "Please also specify warning threshold!\n";
#		displayUsage();
#		exit(STATE_UNKNOWN);
#	}
#	@temperature_w = getThresholds(\@temperature_w, 70);
#	@temperature_c = getThresholds(\@temperature_c, 75);
#	
#	# Input validation
#	my @controllerVersion = `$sudo $arcconf GETVERSION $controller`;
#	if($controllerVersion[1] eq "Invalid controller number.") {
#		print "Invalid controller number, device not found!";
#		exit(STATE_UNKNOWN);
#	}
#	if($zmm != 1 && $zmm != 0) {
#		print "Invalid ZMM parameter, must be 0 or 1!";
#		exit(STATE_UNKNOWN);
#	}
#
#	# Set exit status
#	my $newExitStatus = 0;
#	my $newStatusMessage = '';
#	($newExitStatus, $statusMessage) = getControllerCfg($sudo, $arcconf, $controller, \@temperature_w, \@temperature_c, $zmm);
#	$newStatusMessage .= $statusMessage;
#	$EXITSTATUS = myStatus($newExitStatus, $EXITSTATUS);
#	($newExitStatus, $statusMessage) = getPhysDevCfg($sudo, $arcconf, $controller, $physDevices);
#	$newStatusMessage .= $statusMessage;
#	$EXITSTATUS = myStatus($newExitStatus, $EXITSTATUS);
#	($newExitStatus, $statusMessage) = getLogDevCfg($sudo, $arcconf, $controller, $logDevices);
#	$newStatusMessage .= $statusMessage;
#	$EXITSTATUS = myStatus($newExitStatus, $EXITSTATUS);
#	if($EXITSTATUS == 0) { print "AACRAID OK (Ctrl #$controller)\n"; }
#	elsif($EXITSTATUS == 1) { if($VERBOSITY eq 0) { chop($newStatusMessage); chop($newStatusMessage); } print "AACRAID WARNING (Ctrl #$controller): [$newStatusMessage]\n"; }
#	elsif($EXITSTATUS ==2) { if($VERBOSITY eq 0) { chop($newStatusMessage); chop($newStatusMessage); } print "AACRAID CRITICAL (Ctrl #$controller): [$newStatusMessage]\n"; }
	exit($EXITSTATUS);
}
