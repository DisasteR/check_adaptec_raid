#!/usr/bin/perl -w


use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case);
use Data::Dumper;
use Switch;

our $VERBOSITY = 0;
our $VERSION = '0.1.3.4.6.233-ALPHA';
our $NAME = "Thomas-Krenn AG Adaptec Raid Controller Nagios/Icinga Plugin";
our $EXITSTATUS = 0;
use constant { 
	STATE_OK => 0,
	STATE_WARNING => 1,
	STATE_CRITICAL => 2,
	STATE_UNKNOWN => 3,
 };

# Returns StatusCode 0,1,2,3
sub myStatus {
	my $prevStatus = $_[0];
	my $nextStatus = $_[1];
	my $returnStatus = STATE_OK;
	if ($prevStatus >= $nextStatus) {
		$returnStatus = $prevStatus;
	} else {
		$returnStatus = $nextStatus;
	}
	
	return $returnStatus
}

# Explains the Usage of the plugin, also which options take which values
# TODO: finished?!
sub displayUsage {
	print $NAME . "V.: " . $VERSION ."\n";
	print "Usage:\n";
	print "		-v(-vv,-vvv) --verbose		Sets the verbosity level\n";
	print "		-h --help					Displays the Help page\n";
	print "		-V --version					Displays the Version of the plugin and arcconf\n";
	print "		-C # --controller #			Specifies a Controller number, defaults to 1\n";
	print "		-LD # --logicaldevice #		Specifies one or more Logical Devices, defaults to all\n";
	print "		-PD # --physicaldevice #	Specifies one or more Physical Devies, defaults to all\n";
	print "		-T # --temperature #		Specifies a maximum temperature the RAID-Controller may have, default is 40 C\n";
	print "		-p <str> --path <str>		Specifies the path to arcconf, default is /usr/bin/arcconf or C:\\Programme\\Adaptec\\RemoteArcconf\\arcconf.exe\n";
	print "		-z <bool> --ZMM <bool>		Boolean Value which specifies if an Zero-Maintenance Module is Present (1 is present/0 is not Present). Default is 1\n";
	die;
}

# Displays a short Help text for the user
# TODO: nicer formatting + more help?
sub displayHelp {
	print $NAME . "V.: " . $VERSION ."\n";
	print "This Nagios/Icinga Plugin checks ADAPTEC RAID-Controllers for Warnings/Errors. \n";
	print "Requirements: \n";
	print "* Arcconf\n* Nagios/Icinga\n* sudo\n";
	print "\n In order for this plugin to work properly you need to add nagios to your sudoers file (or create a new one for the nagios user)\n";
	print "It is highly recommended that the nagios user only gets access to arcconf! For example: <nagios user> all nopasswd: /usr/bin/arcconf *\n";
	die;
}
 
# Prints the Name, Version of the Plugin
# Also Prints the name, version of arcconf and the version of the RAID-Controller
# TODO: implement arcconf 1 GETVERSION
sub displayVersion {
	my $sudo = $_[0];
	my $arcconf = $_[1];
	my @arcconfVersion = `$sudo $arcconf`;
	print $NAME . "\nVersion: ". $VERSION . "\n\n";
	#TODO Point out what version is printed here, is there a more clear way?
	foreach my $line (@arcconfVersion){
		if(index($line, "| UCLI |" ) ne "-1") {
			$line =~ s/\s+\|.UCLI.\|\s+//g; # It ain't pretty but it works.
			print $line. "";
		}
	}
}

# Returns Information about the Adaptec RAID-Controller itsself:
#		- Controller Status
#		- Defunctional Disks
#		- Logical Devices which have failed/are degraded
#		- Temperature
# 		- Status of ZMM if present
# TODO: Nagios Dev Guidelines correct Threshold implementation (currently just takes > for warning and +20% for critical)
sub getControllerCfg {
	
	my $sudo = $_[0];
	my $arcconf = $_[1];
	my $controller = $_[2];
	my $temperature = $_[3];
	my $zmm = $_[4];
	my $status = 0; # Return Status
	my $statusMessage = "Controller Status "; # Return String
	my @output = `$sudo $arcconf GETCONFIG $controller AD`; #seems to parse every line in its own variable
	my @linevalues;
	
	foreach my $line (@output) {
		if(index($line, ':') != -1) {
			@linevalues = split(/:/, $line);
			$linevalues[0] =~ s/^\s+|\s+$//g;
			$linevalues[1] =~ s/^\s+|\s+$//g;

			switch($linevalues[0]) {
				# Overall Controller Status
				case "Controller Status" { 
					if ($linevalues[1] ne "Optimal") { 
						$status = myStatus($status, STATE_CRITICAL);
						if ($VERBOSITY == 0) {$statusMessage .= "CRITICAL: Controller Status not Optimal"; }
						if ($VERBOSITY >= 1) {$statusMessage .= "CRITICAL: The Controller Status is not running Optimal"; }	
					}
				}
				# Defunctional disks
				case "Defunct disk drive count" { 
					if ($linevalues[1] ne "0") { 
						$status = myStatus($status, STATE_CRITICAL);
						if ($VERBOSITY == 0) {$statusMessage .= "CRITICAL: Defunctional Disks "; }
						if ($VERBOSITY >= 1) {$statusMessage .= "CRITICAL: Defunctional Disk Count: " . $linevalues[1] . ". "; }
					}
				}
				
				# Logical Devices total/failed/degraded
				# Warning since the raid is still recoverable, if it isnt you wont need a nagios plugin to notice that!
				case "Logical devices/Failed/Degraded" { 
					$linevalues[1] =~ /([0-9]+)\/([0-9]+)\/([0-9]+)/;
					my $totalDisks = $1;
					my $totalFailed = $2;
					my $totalDegraded = $3;
					#TODO Numbers or strings?
					if ($totalFailed ne '0' || $totalDegraded ne '0') { 
						$status = myStatus($status, STATE_WARNING);
						if ($VERBOSITY == 0) {$statusMessage .= "WARNING: Disks Failed/Degraded. "; }
						if ($VERBOSITY == 1) {$statusMessage .= "WARNING: Disks have Failed or the Raid is degraded. "; }	
						if ($VERBOSITY >= 2) {$statusMessage .= "\nWARNING: Disks have Failed or the Raid is degraded: (Total Disks: ". $totalDisks . ", Failed: " . $totalFailed . ", Degraded: " . $totalDegraded . ") " }
					}
				}
				
				# Warning if temperature is over the set Threshold 
				# Critical if 20% over the set Threshold (Will be configureable in the future)
				# http://nagiosplug.sourceforge.net/developer-guidelines.html#THRESHOLDFORMAT
				case "Temperature" {
					my ($controllerTemp) = $linevalues[1] =~ /(^[0-9]+)/;
					my $criticalTemp = $temperature + (2 * ( $temperature / 10 ));
					if ( $controllerTemp > $criticalTemp) {
						$status = myStatus($status, STATE_CRITICAL);
						if ($VERBOSITY == 0) {$statusMessage .= "CRITICAL: Temperature critical: " . $controllerTemp . " C. "; }
						if ($VERBOSITY == 1) {$statusMessage .= "CRITICAL: Temperature critical: (20% over threshold): " . $controllerTemp . " C. "; }	
						if ($VERBOSITY >= 2) {$statusMessage .= "\nCRITICAL: Temperature critical: (20% over threshold: ". $criticalTemp . " C):" . $controllerTemp . " C. "; }
					} elsif ($controllerTemp > $temperature) {
						$status = myStatus($status, STATE_WARNING);
						if ($VERBOSITY == 0) {$statusMessage .= "WARNING: Temperature Warning:" . $controllerTemp . " C. "; }
						if ($VERBOSITY == 1) {$statusMessage .= "WARNING: Temperature Warning (Threshold: ". $temperature. " C): " . $controllerTemp . " C. "; }
						if ($VERBOSITY >= 2) {$statusMessage .= "\nWARNING: Temperature Warning (Threshold: ". $temperature. ", Critical Threshold:". $criticalTemp ." C):" . $controllerTemp . " C. "; }
					}		
				}
				
				# Zero Maintenance Module
				case "Status" { 
					if ( $zmm == 1) {
						if ($linevalues[1] ne "ZMM Optimal") { 
							$status = myStatus($status, STATE_CRITICAL);
							if ($VERBOSITY == 0) {$statusMessage .= "CRITICAL: ZMM Not Optimal!"; }
							if ($VERBOSITY >= 1) {$statusMessage .= "CRITICAL: Zero Maintenance Module Error or Module not found!"; }	
						}
					}
				}
			}
		}
		
	}
	
	if ($status eq 0) {
		print $statusMessage . "OK";
	} else {
		print $statusMessage;
	}
	return $status
}


sub getPhysDevCfg {
	my $sudo = $_[0];
	my $arcconf = $_[1];
    my $controller = $_[2];
    my @devices = $_[3];
    my $devicenum = -1;
    my $status = 0; #Return Status
    my $statusMessage = "Physical Device Status: "; # Return String
    my @faildevices;
    my @output = `$sudo $arcconf GETCONFIG $controller PD`;
    my %hash;
    my @linevalues;
    
    foreach my $line (@output) {
        if($line =~ /(Device #)([0-9]+)/) {
        	if(!defined($devices[0])) {
        		$devicenum = $2;
        	} else {
        		if(grep {$_ eq $2} @devices) {
        			$devicenum = $2;
        		} else {
        			$devicenum = -1;
        		}
        	}
        }
        if($devicenum ne -1 && index($line, ':') != -1) {
            @linevalues = split(/:/, $line);
            $linevalues[0] =~ s/^\s+|\s+$//g;
            $linevalues[1] =~ s/^\s+|\s+$//g;
            $hash{$linevalues[0]} = $linevalues[1];

            switch($linevalues[0]) {
            
            	# Main disk status (Online/Offline?)
                case "State" {
                    if ($linevalues[1] ne "Online") {
                    	if (scalar(@faildevices) eq 0 || !grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY >= 1) {$statusMessage .= "CRITICAL: Disk $devicenum is not online."; }
                    }
                }
            	
            	# Overall S.M.A.R.T. status
                case "S.M.A.R.T." {
                    if ($linevalues[1] ne "No") {
                    	if (scalar(@faildevices) eq 0 || !grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                    	$status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY >= 1) {$statusMessage .= "CRITICAL: Disk $devicenum: S.M.A.R.T. status not ok."; }
                    }
                }
            	
            	# Check if any S.M.A.R.T. warnings occured
                case "S.M.A.R.T. warnings" {
                    if ($linevalues[1] ne "0") {
                    	if (scalar(@faildevices) eq 0 || !grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_WARNING);
                        if ($VERBOSITY == 1) {$statusMessage .= "WARNING: Disk $devicenum: S.M.A.R.T. warning."; }
                        if ($VERBOSITY >= 2) {$statusMessage .= "WARNING: Disk $devicenum: S.M.A.R.T. warnings is more than zero."; }
                    }
                }
            	
            	# Look for bad device segments
                case "Failed logical device segments" {
                	if ($linevalues[1] eq "True") {
                    	if (scalar(@faildevices) eq 0 || !grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY >= 1) {$statusMessage .= "CRITICAL: Disk $devicenum has failed logical device segments."; }
                	}
                }
            }
        }
    }
    
    # Status output
    my $faildevicenum = scalar(@faildevices);
    if ($VERBOSITY eq 0 && $faildevicenum > 0) {
    	if ($status eq 1) {
    		$statusMessage = "WARNING: Problems with $faildevicenum physical disk(s).";
    	} else {
    		$statusMessage = "CRITICAL: Problems with $faildevicenum physical disk(s)."
    	}
    }
	if ($status eq 0) {
		print $statusMessage . "OK";
	} else {
		print $statusMessage;
	}
    return $status
}


sub getLogDevCfg {
	my $sudo = $_[0];
	my $arcconf = $_[1];
    my $controller = $_[2];
    my @devices = $_[3];
    my $devicenum = -1;
    my $status = 0;
    my $statusMessage = "Logical Device Status: ";
    my @faildevices;
    my @output = `$sudo $arcconf GETCONFIG $controller LD`;
    my %hash;
    my @linevalues;
   
    foreach my $line (@output) {
        if($line =~ /(Logical device number )([0-9]+)/) {
        	if(!defined($devices[0])) {
        		$devicenum = $2;
        	} else {
        		if(grep {$_ eq $2} @devices) {
        			$devicenum = $2;
        		} else {
        			$devicenum = -1;
        		}
        	}
        }
        if($devicenum ne -1 && index($line, ':') != -1) {
            @linevalues = split(/:/, $line);
            $linevalues[0] =~ s/^\s+|\s+$//g;
            $linevalues[1] =~ s/^\s+|\s+$//g;
			#TODO $hash is only used here once
            $hash{$linevalues[0]} = $linevalues[1];

            switch($linevalues[0]) {
            
            	# Main logical device status (Optimal/Failed?)
                case "Status of logical device" {
                    if ($linevalues[1] ne "Optimal") {
                    	if (scalar(@faildevices) eq 0 || !grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                        $status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY >= 1) {$statusMessage .= "CRITICAL: Status of logical disk $devicenum is not optimal."; }
                    }
                }
            	
            	# Check for failed stripes
                case "Failed stripes" {
                    if ($linevalues[1] ne "No") {
                    	if (scalar(@faildevices) eq 0 || !grep {$_ eq $devicenum} @faildevices) {
                    		push(@faildevices, $devicenum);
                    	}
                    	$status = myStatus($status, STATE_CRITICAL);
                        if ($VERBOSITY >= 1) {$statusMessage .= "CRITICAL: Logical disk $devicenum has failed stripes."; }
                    }
                }
            }
        }
    }
    
    # Status output
    my $faildevicenum = scalar(@faildevices);
    if ($VERBOSITY eq 0 && $faildevicenum > 0) {
    	if ($status eq 1) {
    		$statusMessage = "WARNING: Problems with $faildevicenum logical disk(s).";
    	} else {
    		$statusMessage = "CRITICAL: Problems with $faildevicenum logical disk(s)."
    	}
    }
    # Wenn Status hier nu immer OK is dann print "Physical Device Status: OK"
	if ($status eq 0) {
		print $statusMessage . "OK";
	} else {
		print $statusMessage;
	}
    return $status
}


MAIN: {
	my $controller = 1;
	my @logDevices; 
	my @physDevices;
	my $sudo = ''; 
	my $arcconf = '';
	my @returnCodes;
	my $platform = $^O;
 	my $temperature = 40;
 	my $zmm = 1; # boolean
	
	if ( !(GetOptions(
		'v|verbose' => sub {$VERBOSITY = 1 },
		'vv' => sub {$VERBOSITY = 2},
		'vvv' => sub {$VERBOSITY = 3},
		'h|help' => sub {displayHelp();},
		'V|version' => sub {displayVersion($sudo, $arcconf);},
		'C|controller=i' => \$controller,
		'LD|logicaldevice=i{,}' => \@logDevices,
		'PD|physicaldevice=i{,}' => \@physDevices, 
		'T|temperature=i' => \$temperature,
		'p|path=s' => \$arcconf,
		'z|ZMM=i' => \$zmm
	)))	{
		displayUsage();
	}
 	
 	# Input validation
	if(!$zmm =~ /(^[0-1]+)/) {
 		print "Invalid ZMM parameter, must be 0 or 1!";
		exit(3);
	}

	# Check platform
	if ($platform eq 'linux') {
		chomp($sudo= `which sudo`);
		if ($arcconf eq '') {
			$arcconf = '/usr/bin/arcconf';
		}
		unless ( -e $arcconf && -x $sudo ) {
			print "Permission denied or file not found!\n";
			exit(3);
		}
	} else {
		$sudo = '';
		if ($arcconf eq '') {
			$arcconf = 'C:\Programme\Adaptec\RemoteArcconf\arcconf.exe';
		}
		unless ( -e $arcconf ) { print "Executable not found!\n"; exit(3); }
	}

	# Set exit status
	$EXITSTATUS = myStatus(getControllerCfg($sudo, $arcconf, $controller, $temperature, $zmm), $EXITSTATUS);
	$EXITSTATUS = myStatus(getPhysDevCfg($sudo, $arcconf, $controller, @physDevices), $EXITSTATUS);
	$EXITSTATUS = myStatus(getLogDevCfg($sudo, $arcconf, $controller, @logDevices), $EXITSTATUS);
	return $EXITSTATUS;
}

__END__

=head1 NAME

check_adaptec_raid - nagios/icinga plugin to check adaptec raid controllers

=head1 VERSION

This document describes plugin version 0.0.1

=head1 DESCRIPTION

=head1 METHODS

=head2 myStatus

TODO: Description

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2013,
Martin Grubhofer C<< <mgrubhofer@thomas-krenn.com> >>.
Franz Nemeth C<< <fnemeth@thomas-krenn.com> >>.
All rights reserved.

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See L<perlartistic>.

=head1 DISCLAIMER OF WARRANTY

BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.


